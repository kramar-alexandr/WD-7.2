external function Boolean IsEnterprise();external function Boolean HasItemGroups();external function Boolean HasContactClassification();external function Boolean HasItemClassification();external procedure InvListVarieties(record RcVc,record INVc,string,string,string,string,record CostAccBlock,Boolean,var Boolean,                                    var Boolean,var string,var val,var val,var val,var val,roundmode,var val,string,vector val);external procedure HTConsigment(Integer, var string);external procedure FindStockValueAtPosition(string,string,string,var record PISVc);external procedure AddSupersessionsInvList(record RcVc,record INVc,string,record CostAccBlock,roundmode,string,var val,var val,var val);external function roundmode GetCostRoundMode(record RoundBlock);external function roundmode DefaultRoundMode();external procedure GetItemCostPrc(record INVc,record CostAccBlock,record ITVc,Integer,var val);external procedure PrintSerialNumbers_InvVal(record INVc,string,Integer,val,Date,string,Integer); external function val ConsigmentStockQty(string,string,Date);external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);external function Integer ArtCodeCostPricePerLocation(string);external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);external function val GetStockQty(string,string,Date,Boolean);external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);external function Integer ItemCostPerLocation(record INVc);external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);external function Boolean FindItemVAR(string,var string,var string,var string,var string);external function val GetStockQty2(string,string,Date,Boolean,Integer);external procedure HTArts(string, string, var string);external procedure HTDepartment(string,var string);external procedure HTArtGroup(string, var string);external procedure HTSupplier(string, var string);external procedure GetItemGroupDescription(string,var string);external procedure CalcSum(val,val,val,val,var val,Integer);external procedure FindStockValue2(record INVc,string,string,Integer,Date,Integer,Boolean,var val,var val,var val,Integer,Integer,Integer,Integer,Boolean,vector val);external procedure HTItemClass(string,var string);external procedure HTCustClassType(string,var string);external function Boolean SetInSet2(string,string);external procedure ItemClassTypef(string,string,var Boolean);external function Boolean FillItemVarArray(string,string,date,var array string,var array val,var Integer,var string,var string,var string,var string);external function val AbsoluteVal(val); //Edit***************************Sasha2,14:05 04.09.2014function integer GetSign(val qty) //Edit***************************Sasha2,15:47 04.09.2014 {begin  integer res;  if (qty<0) then begin  	res = -1;  end else begin  	res = 1;	  end;  GetSign = res;  return;end; //Edit***************************Sasha2,15:47 04.09.2014 }//Edit***************************Sasha2,11:57 03.09.2014 {procedure PrintData(record RcVc RepSpec, record INVc INr,record ItemHistVc IHr,string tstr,integer prlstcnt,array val prices) begin  integer i, pos;  record PUVc PUr;      pos = 0; 	StartFormat(15);		OutString(pos,0,INr.Group,false);	    OutString(pos+=20,0,INr.Code,false);	    OutString(pos+=30,0,INr.Name,false);	    OutString(pos+=50,0,INr.Unittext,false);	    OutString(pos+=30,"DblItemHistLine",tstr,false);	    OutDate(pos+=50,0,IHr.TransDate,false);	    OutString(pos+=30,0,IHr.Location,false);	    if (RepSpec.flags[10]==1) then begin	    	OutString(pos+=20,0,IHr.SerialNr,false);	    end;	    if (blankdate(RepSpec.d1)) then begin			OutVal(pos+=30,0,IHr.RemQty,M4Qty,false);		end else begin			OutVal(pos+=30,0,IHr.Qty,M4Qty,false);			end;	    OutString(pos+=20,0,IHr.PUCurncyCode,false);	    PUr.SerNr = IHr.InSerNr;	    ReadFirstMain(PUr,1,true);	    OutString(pos+=25,0,PUr.FrRate & " : " & PUr.ToRateB1,false);	    OutVal(pos+=15,0,AbsoluteVal(IHr.TotCostPriceCurncy/IHr.Qty),M45Val,false);	    if (blankdate(RepSpec.d1)) then begin			OutVal(pos+=35,0,(IHr.TotCostPriceCurncy/IHr.Qty)*IHr.RemQty,M45Val,false);		end else begin			OutVal(pos+=35,0,IHr.TotCostPriceCurncy*GetSign(IHr.Qty),M45Val,false);			end;	    OutVal(pos+=30,0,AbsoluteVal(IHr.TotCostPrice/IHr.Qty),M45Val,false);	    if (blankdate(RepSpec.d1)) then begin			OutVal(pos+=30,0,(IHr.TotCostPrice/IHr.Qty)*IHr.RemQty,M45Val,false);		end else begin			OutVal(pos+=30,0,IHr.TotCostPrice*GetSign(IHr.Qty),M45Val,false);			end;	    for (i=0;i<prlstcnt;i=i+1) begin	    	OutVal(pos+=30,0,prices[i],M45Val,false);	    end;	EndFormat;    returnend; //Edit***************************Sasha2,11:57 03.09.2014 }//Edit***************************Sasha2,11:58 03.09.2014 {procedure GetIHFileName(record ItemHistVc IHr,var string tstr)begin		  switch (IHr.FileName) begin	    case "IVVc": tstr = USetStr(1150);	    case "PUVc": tstr = USetStr(1157);      	    case "ProdVc": tstr = USetStr(1162);	    case "RetVc": tstr = USetStr(1421);	    case "StockMovVc": tstr = USetStr(1172);	    case "StockTakeVc": tstr = USetStr(1392);	    case "ProdOperationVc": tstr = USetStr(1633);	    case "SRVc": tstr = USetStr(1636);	    	    case "SHVc": tstr = USetStr(5003);	    case "IVCashVc": tstr = USetStr(11675);	    case "SDVc": tstr = USetStr(5020);	    case "WSVc": tstr = USetStr(7650);	    case "INTransferVc": tstr = USetStr(5040);	  end;	  tstr = tstr & ":";	  tstr = tstr & IHr.TransNr;  return;	  end; //Edit***************************Sasha2,11:58 03.09.2014 }procedure LoopNewInvVal(record RcVc RepSpec,integer prlstcnt,array string prlists,integer rempos,integer costpos,integer totcostpos)begin  record INVc INr;  record ItemHistVc IHr;  record PLVc PLr;  record ItemStatusVc ISr;  boolean TrHs,testf,TrHs1,testf1,print;  string 255 tstr;  array val prices;  integer i,pos,itemqty;  val itemsum,itemcostsum,itemrem,totcostsum,totsum,totrem;  string 20 IHkey;    	itemsum = 0;  	itemcostsum = 0;  	itemrem = 0;  	totcostsum = 0;  	totsum = 0;  	totrem = 0;    	if (blankdate(RepSpec.d1)) then begin		IHkey = "ActiveQty";	end else begin		IHkey = "ArtCode";		end;	  	TrHs = true;  	INr.Code = "";	while (LoopMain(INr,1,TrHs)) begin		testf = true;		if (NonBlank(RepSpec.f1) and !SetInSet(INr.Code,RepSpec.f1)) then begin testf = false; end;		if (RepSpec.flags[18]==0 and INr.Terminated<>0) then begin testf = false; end;		if (INr.ItemType!=kItemTypeStocked) then begin testf = false; end;		if (testf) then begin						itemsum = 0;		  	itemcostsum = 0;		  	itemrem = 0;		  	itemqty = 0;			for (i=0;i<prlstcnt;i=i+1) begin				PLr.PLCode = prlists[i];				PLr.ArtCode = INr.Code;				if (ReadFirstMain(PLr,2,true)) then begin					prices[i] = PLr.ExVatPrice;				end;			end;						TrHs1 = true;			print = false;			IHr.ArtCode = INr.Code;			while (LoopKey(IHkey,IHr,1,TrHs1)) begin				testf1 = true;				if (IHr.ArtCode!=INr.Code) then begin TrHs1 = false; testf1 = false; end;				if (NonBlank(RepSpec.f2) and !SetInSet(IHr.Location,RepSpec.f2)) then begin testf1 = false; end; 				if (nonblankdate(RepSpec.d1) and RepSpec.d1<IHr.TransDate) then begin testf1 = false; end;				if (IHr.StockAffectf!=1) then begin testf1 = false; end;				if (testf1) then begin					if (blankdate(RepSpec.d1)) then begin						itemrem = itemrem + IHr.RemQty;						totrem = totrem + IHr.RemQty;						itemcostsum = itemcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);		    			totcostsum = totcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);						itemsum = itemsum + (IHr.TotCostPrice/IHr.Qty)*IHr.RemQty;		    			totsum = totsum + (IHr.TotCostPrice/IHr.Qty)*IHr.RemQty;					end else begin						itemrem = itemrem + IHr.Qty;						totrem = totrem + IHr.Qty;						itemcostsum = itemcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);		    			totcostsum = totcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);						itemsum = itemsum + IHr.TotCostPrice*GetSign(IHr.Qty);		    			totsum = totsum + IHr.TotCostPrice*GetSign(IHr.Qty);						end;	    			itemqty = itemqty + 1;	    			if (RepSpec.ArtMode==1) then begin	    				GetIHFileName(IHr,tstr);	    				PrintData(RepSpec,INr,IHr,tstr,prlstcnt,prices);	    			end;					print = true;				end;			end; RESETLOOP(IHr);			if (print) then begin				if (RepSpec.ArtMode==0) then begin					pos = 0; 					StartFormat(15);					OutString(pos,0,INr.Group,false);	    			OutString(pos+=30,0,INr.Code,false);	    			OutString(pos+=50,0,INr.Name,false);	    			OutString(pos+=70,0,INr.Unittext,false);	    			OutVal(rempos,0,itemrem,M45Val,false);	    			pos = rempos;	    			ISr.Code = INr.Code;	    			ISr.Location = ";;;";	    			ReadFirstMain(ISr,2,true);	    			OutVal(pos+=30,0,ISr.RsrvQty,M45Val,false);	    			OutVal(costpos,0,itemcostsum/itemqty,M45Val,false);			  		OutVal(totcostpos,0,itemsum,M45Val,false);			  		pos = totcostpos;			  		for (i=0;i<prlstcnt;i=i+1) begin	    				OutVal(pos+=40,0,prices[i],M45Val,false);	    			end;	    			EndFormat;				  	Gray_Divider(0,1);				end;				if (RepSpec.ArtMode==1) then begin					Black_Divider(2,1);					StartFormat(15);					if (RepSpec.Media == mtExcel or RepSpec.Media == mtFile) then begin						OutString(rempos,0,"",false);			  			OutString(costpos,0,"",false);			  			OutString(totcostpos,0,"",false);					end else begin						OutVal(rempos,0,itemrem,M45Val,false);			  			OutVal(costpos,0,itemcostsum/itemqty,M45Val,false);			  			OutVal(totcostpos,0,itemsum,M45Val,false);					end;				  	EndFormat;				  	Gray_Divider(0,1);				end;			  	print = false;			end;					end;		end;	  return;end;global  //Edit***************************Sasha2,11:43 02.09.2014 {procedure NewInvValRn(record RcVc RepSpec)begin  record RoundBlock RoundRec;  record CostAccBlock CAb;  record MainStockBlock mst;  val nr,nrq2;  val sum1;  Integer vatflag;  string 255 tstr;  Integer rw;  vector val vlocationtotals;  Boolean found;  record LocationVc Locr;  integer pos,rempos,costpos,totcostpos;  record PLdefVc PLdefr; //Edit***************************Sasha2,13:03 03.09.2014  integer  prlstcnt,i; //Edit***************************Sasha2,13:03 03.09.2014  array string 15 prlists; //Edit***************************Sasha2,13:03 03.09.2014    BlockLoad(mst);  BlockLoad(CAb);  BlockLoad(RoundRec);  vatflag = 0;  StartReportJob(USetStr(2322) & " (modified)");  if (RepSpec.PocketPC == 0) then begin    rw = 1;    if ((nonblank(RepSpec.f1)) or (blank(RepSpec.AccStr))) then begin      HTArts(RepSpec.f1,RepSpec.f1,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblank(RepSpec.AccStr)) then begin      HTDepartment(RepSpec.AccStr,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblank(RepSpec.f2)) then begin      tstr = USetStr(2768);      tstr = RepSpec.f2;      Header(rw,tstr,0);    end;    if (HasItemGroups) then begin      HTArtGroup(RepSpec.f3,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;    end;    if (nonblank(RepSpec.FirstAcc)) then begin      tstr = USetStr(2779) & " " & RepSpec.FirstAcc;      Header(rw,tstr,0);    end;    if (HasItemClassification) then begin      HTItemClass(RepSpec.f4,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (HasContactClassification) then begin      HTCustClassType(RepSpec.f5,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (nonblank(RepSpec.LastAcc)) then begin      HTSupplier(RepSpec.LastAcc,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if ((ProgramType!=typFirstOffice) and IsBooks==false) then begin      if (RepSpec.flags[1]==0) then begin        tstr = USetStr(2345);       end;        if (RepSpec.flags[1]==1) then begin        tstr = USetStr(2346);            end;        Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblankdate(RepSpec.d1)) then begin      tstr = RepSpec.d1;      Header(rw,tstr,1);      rw = rw + 1;    end;    if (IsEnterprise) then begin      HTConsigment(RepSpec.flags[12],tstr);      Header(rw,tstr,0);    end;    switch (RepSpec.flags[11]) begin      case 0:         switch (CAb.PrimaryCostModel) begin          case 4:            tstr = USetStr(10554 + CAb.QueuedCostModel);          otherwise            tstr = USetStr(10550 + CAb.PrimaryCostModel);        end;            case 1: tstr = USetStr(10550+RepSpec.flags[11]);      case 2: tstr = USetStr(10550+RepSpec.flags[11]);      case 3: tstr = USetStr(10550+RepSpec.flags[11]);      otherwise /*wierd              switch (CAb.PrimaryCostModel) begin          case 4:            tstr = USetStr(10554 + CAb.QueuedCostModel);          otherwise            tstr = USetStr(10550 + CAb.PrimaryCostModel);        end;*/                tstr = USetStr(10554 + CAb.QueuedCostModel);    end;    Header(rw,USetStr(10549) & ": " & tstr,1);    rw = rw + 1;  end else begin  end;  EndHeader;  if (blank(RepSpec.f5) and (RepSpec.flags[2]==4)) then begin    StartFormat(15);    OutString(140,0,USetStr(20098),false);    EndFormat;      goto LInvValRn;  end;  if (RepSpec.PocketPC== 0) then begin    SetRepCol(2,70);    SetRepColBiDi(3,310,350);    SetRepColBiDi(4,400,440);    SetRepCol(5,240);    SetRepColBiDi(6,480,505);  end else begin    SetRepCol(2,100);    SetRepCol(3,380);    SetRepCol(4,400);    SetRepCol(5,240);  end;    	prlstcnt = 0; //Edit***************************Sasha2,13:09 03.09.2014 {	PLdefr.Code ="";	while (LoopMain(PLdefr,1,true)) begin		if (NonBlank(PLdefr.Code)) then begin			prlists[prlstcnt] = PLdefr.Code;			prlstcnt = prlstcnt + 1;		end;	end; //Edit***************************Sasha2,13:09 03.09.2014 }    if ((RepSpec.ArtMode==0) or (RepSpec.ArtMode==2)) then begin  	pos = 0;  	StartFormat(15);	OutString(pos,0,USetStr(2338),false);    OutString(pos+=30,0,USetStr(2325),false);    OutString(pos+=50,0,USetStr(2326),false);    OutString(pos+=70,0,USetStr(2327),false);    OutStringAdjust(pos+=30,0,USetStr(2330),false,M4Val);    rempos = pos;    OutString(pos+=30,0,USetStr(11540),false); //резерв    OutStringAdjust(pos+=30,0,USetStr(2331),false,M4Val); //Закуп.вар-ть    costpos = pos;    OutStringAdjust(pos+=40,0,USetStr(2332),false,M4Val); //Сума    totcostpos = pos;    for (i=0;i<prlstcnt;i=i+1) begin    	 OutString(pos+=40,0,prlists[i],false);    end;     //OutStringAdjust(pos+=30,0,USetStr(2335),false,M4Val);    EndFormat;    Gray_Divider(0,1);  end;    if (RepSpec.ArtMode==1) then begin  	pos = 0;	StartFormat(15);	OutString(pos,0,USetStr(2338),false);    OutString(pos+=20,0,USetStr(2325),false);    OutString(pos+=30,0,USetStr(2326),false);    OutString(pos+=50,0,USetStr(2327),false);    OutString(pos+=30,0,USetStr(2344),false);    OutString(pos+=50,0,USetStr(2353),false);    OutString(pos+=30,0,USetStr(2569),false);    if (RepSpec.flags[10]==1) then begin    	OutString(pos+=20,0,USetStr(5018),false);    end;    OutStringAdjust(pos+=30,0,USetStr(2330),false,M4Val);    rempos = pos;    OutString(pos+=20,0,USetStr(2514),false);    OutString(pos+=25,0,USetStr(5247),false);    OutString(pos+=15,0,USetStr(2331) & "," & USetStr(2519),false);    OutString(pos+=35,0,USetStr(2332) & "," & USetStr(2519),false);    /*if (RepSpec.flags[11]==1) then begin      OutStringAdjust(pos+=30,0,USetStr(2350),true,M4Val);    end else begin*/      OutStringAdjust(pos+=30,0,USetStr(2331),false,M4Val);      costpos = pos;    //end;    OutStringAdjust(pos+=30,0,USetStr(2332),false,M4Val);    totcostpos = pos;    for (i=0;i<prlstcnt;i=i+1) begin    	 OutString(pos+=30,0,prlists[i],false);    end;     //OutStringAdjust(pos+=30,0,USetStr(2335),false,M4Val);    EndFormat;    Gray_Divider(0,1);  end;  if (RepSpec.ArtMode==3) then begin    StartFormat(15);    OutString(0,0,USetStr(5010),false);    OutStringAdjust(5,0,USetStr(5279),true,M4Val);    EndFormat;  end;  LoopNewInvVal(RepSpec,prlstcnt,prlists,rempos,costpos,totcostpos);    /*if (RepSpec.ArtMode==3) then begin //Edit***************************Sasha2,17:56 03.09.2014    Locr.Code = RepSpec.f2;    found = true;    while (LoopMain(Locr,1,found)) begin      if (nonblank(RepSpec.f2)) then begin        if (Locr.Code!=RepSpec.f2) then begin found = false; end;      end;      if (found) then begin        if (vlocationtotals[Locr.Code]!=0) then begin          StartFormat(15);          OutString(0,0,Locr.Code,false);          OutVal(5,0,vlocationtotals[Locr.Code],M4UVal,true);          sum1 = sum1 + vlocationtotals[Locr.Code];          EndFormat;        end;      end;    end;    Gray_Divider(0,1);    StartFormat(15);    OutVal(5,0,sum1,M4UVal,true);    EndFormat;  end else begin    if (RepSpec.ArtMode==0) then begin      Gray_Divider(0,1);    end;      StartFormat(15);    if (RepSpec.Media==mtFile or RepSpec.Media==mtExcel) then begin      OutString(2,0,"",false);      OutString(2,0,"",false);      OutString(2,0,"",false);    end;    OutVal(3,0,nr,M4UVal,true);    if (RepSpec.flags[15]==1) then begin        OutValBiDi(350,0,nrq2,M4UVal,true,390);    end;      if (RepSpec.Media==mtFile or RepSpec.Media==mtExcel) then begin      OutString(2,0,"",false);    end;    OutVal(6,0,sum1,M45Val,true);    EndFormat;  end;*/LInvValRn:;   EndJob;  return;end;  //Edit***************************Sasha2,11:43 02.09.2014 }